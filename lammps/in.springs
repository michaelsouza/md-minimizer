# LAMMPS input script for tensile test with avalanche dynamics.
#
# This script implements the quasi-static loading method described in
# Noguchi et al. (2024). It should be run with a variable pointing to the data file.
# Example: lmp -in lammps/in.springs -v data_file lammps/N12_Lmat4.data

log             lammps/log.lammps

print           "IN.SPRINGS (VERSION 3.2 - FINAL PYTHON FIX)"

# --- 1. Initialization & System Definition ---
variable        data_file index "lammps/N12_Lmat4.data"
variable        thresholds_filename index "lammps/N12_Lmat4_breaking_thresholds.dat"

units           lj
dimension       2
boundary        p s p
atom_style      bond

# --- 2. Define Interaction Potentials ---
bond_style      harmonic
pair_style      none

# --- 3. System Setup ---
read_data       ${data_file}
group           bottom_atoms type 2
group           top_atoms type 3
group           mobile_atoms type 1

# --- 4. Simulation Settings ---
variable        total_steps equal 200
variable        strain_inc equal 1.0e-3
variable        current_step equal 0
variable        num_broken_total equal 0

fix             1 bottom_atoms setforce 0.0 0.0 0.0
thermo          1
thermo_style    custom step v_current_step pe press pyy v_num_broken_total

# --- Define placeholder variables for Python to modify ---
variable        p_bondtype string "none"
variable        p_breaklen string "none"
variable        p_is_eof equal 0

# --- 5. Main Simulation Loop (Quasi-static Loading) ---
label           main_loop
variable        current_step loop ${total_steps}
print           "--- Strain Step ${current_step}/${total_steps} ---"
displace_atoms  top_atoms move 0 ${strain_inc} 0

# Avalanche Loop
label           avalanche_loop
    minimize        1.0e-5 1.0e-7 1000 10000
    variable        bonds_before equal count(all,bonds)

    # --- Setup bond breaking ---
    variable        break_file file ${thresholds_filename}
    label           setup_loop
        variable        current_line index ${break_file}

        # ROBUST FIX: Define and invoke the python function *inside* the loop
        # This ensures it captures the current value of the v_current_line variable.
        python          process_line input 2 SELF v_current_line format ps here """
def process_line(lmpptr, line):
    from lammps import lammps
    lmp = lammps(ptr=lmpptr)
    if not line or line.strip() == "EOF":
        lmp.set_variable("p_is_eof", 1)
        return
    try:
        parts = line.strip().split()
        if len(parts) >= 2:
            lmp.set_variable("p_bondtype", parts[0])
            lmp.set_variable("p_breaklen", parts[1])
            lmp.set_variable("p_is_eof", 0)
        else:
            lmp.set_variable("p_is_eof", 1)
    except Exception as e:
        print(f"Python error processing line '{line}': {e}")
        lmp.set_variable("p_is_eof", 1)
"""
        python          process_line invoke

        if ${p_is_eof} then "jump SELF setup_done"

        print           "DEBUG SETUP: Applying fix Br_${p_bondtype} with type ${p_bondtype} and length ${p_breaklen}"
        fix             Br_${p_bondtype} all bond/break 1 ${p_bondtype} ${p_breaklen}

        variable        current_line delete
        jump            SELF setup_loop
    label           setup_done
    variable        break_file delete
    variable        current_line delete

    print           "DEBUG: Running simulation for 1 step to trigger breaks."
    run 1

    # --- Cleanup bond breaking fixes ---
    variable        break_file file ${thresholds_filename}
    label           cleanup_loop
        variable        current_line index ${break_file}

        # Redefine and invoke the function again for the cleanup pass
        python          process_line input 2 SELF v_current_line format ps here """
def process_line(lmpptr, line):
    from lammps import lammps
    lmp = lammps(ptr=lmpptr)
    if not line or line.strip() == "EOF":
        lmp.set_variable("p_is_eof", 1)
        return
    try:
        parts = line.strip().split()
        if len(parts) >= 2:
            lmp.set_variable("p_bondtype", parts[0])
            lmp.set_variable("p_breaklen", parts[1])
            lmp.set_variable("p_is_eof", 0)
        else:
            lmp.set_variable("p_is_eof", 1)
    except Exception as e:
        print(f"Python error processing line '{line}': {e}")
        lmp.set_variable("p_is_eof", 1)
"""
        python          process_line invoke

        if ${p_is_eof} then "jump SELF cleanup_done"

        print           "DEBUG CLEANUP: Removing fix Br_${p_bondtype}"
        unfix           Br_${p_bondtype}

        variable        current_line delete
        jump            SELF cleanup_loop
    label           cleanup_done
    variable        break_file delete
    variable        current_line delete

    # Check if any bonds were broken
    variable        bonds_after equal count(all,bonds)
    variable        num_broken_iter equal ${bonds_before}-${bonds_after}
    variable        num_broken_total equal ${num_broken_total}+${num_broken_iter}

    print           "Avalanche iteration: Broke ${num_broken_iter} bonds."
    if "${num_broken_iter} > 0" then { jump SELF avalanche_loop }

# Dump configuration
dump            DUMP all custom 10 dump.step${current_step}.lammpstrj id type x y z
run             0
undump          DUMP

print           "Avalanche finished for strain step ${current_step}. Total broken: ${num_broken_total}"
next            current_step
jump            SELF main_loop

print           "Simulation finished."