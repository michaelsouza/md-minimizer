"""springs.py
Runs a quasi-static tensile test with avalanche dynamics by driving the top
atoms upward in small strain increments and allowing bond breaking according
to per-bond thresholds read from an external file.

Usage (example):
    python lammps/springs.py \
        --data-file lammps/N12_Lmat4.data \
        --thresholds lammps/N12_Lmat4_breaking_thresholds.dat

Requirements:
    * lammps (Python module, compiled with PYTHON, MC, MOLECULE packages)
    * numpy (only for float casting convenience)

Author: Auto-generated by Cascade AI (2025-06-17)
"""
from __future__ import annotations

import argparse
import pathlib
import sys
from typing import Tuple, List  # pylint: disable=unused-import

try:
    from lammps import lammps  # type: ignore
except ImportError as e:  # pragma: no cover
    sys.stderr.write(
        "Error: LAMMPS python module not found. Ensure you built LAMMPS with the\n"
        "PYTHON package and that it is in PYTHONPATH.\n"
    )
    raise

# -----------------------------------------------------------------------------
# Helper functions
# -----------------------------------------------------------------------------


def parse_thresholds(path: pathlib.Path) -> List[Tuple[int, float]]:
    """Read `thresholds_file` and return list of (bond_type, break_length)."""
    pairs: List[Tuple[int, float]] = []
    with path.open() as fh:
        for line in fh:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            try:
                bond_type: int = int(parts[0])
                break_len: float = float(parts[1])
            except ValueError:
                continue  # skip malformed lines
            pairs.append((bond_type, break_len))
    if not pairs:
        raise ValueError(f"No valid thresholds found in {path}")
    return pairs


# -----------------------------------------------------------------------------
# Core simulation routine
# -----------------------------------------------------------------------------


def run_simulation(
    data_file: pathlib.Path,
    thresholds_file: pathlib.Path,
    total_steps: int = 200,
    strain_inc: float = 1.0e-3,
    lmp_cmdargs: Tuple[str, ...] = (),
):
    """Execute the quasi-static tensile test."""
    if not data_file.is_file():
        raise FileNotFoundError(data_file)
    if not thresholds_file.is_file():
        raise FileNotFoundError(thresholds_file)

    # Pre-parse thresholds to speed up loops
    threshold_pairs = parse_thresholds(thresholds_file)

    # Create LAMMPS instance
    lmp = lammps(cmdargs=list(lmp_cmdargs))

    # --- Initialization & system definition ---
    lmp.commands_list([
        "units lj",
        "dimension 2",
        "boundary p s p",
        "atom_style bond",
        "bond_style harmonic",
        "pair_style none",
        f"read_data {data_file}",
        "group bottom_atoms type 2",
        "group top_atoms    type 3",
        "group mobile_atoms type 1",
        "fix 1 bottom_atoms setforce 0.0 0.0 0.0",
        "thermo 1",
        "thermo_style custom step pe press pyy",
    ])

    num_broken_total = 0

    for step_id in range(total_steps):
        print(f"--- Strain Step {step_id + 1}/{total_steps} ---", flush=True)

        # Apply displacement (strain increment)
        lmp.command(f"displace_atoms top_atoms move 0 {strain_inc} 0")

        # Avalanche loop
        while True:
            lmp.command("minimize 1.0e-5 1.0e-7 1000 10000")

            # Count bonds before breaking
            lmp.command("variable bonds_now equal bonds")
            bonds_before = int(lmp.extract_variable("bonds_now", None, 0))

            # --- Setup bond/break fixes ---
            for bond_type, break_len in threshold_pairs:
                fix_name = f"Br_{bond_type}"
                lmp.command(
                    f"fix {fix_name} all bond/break 1 {bond_type} {break_len}"
                )

            # One MD step to trigger breaks
            lmp.command("run 1 post no")

            # --- Cleanup ---
            for bond_type, _ in threshold_pairs:
                fix_name = f"Br_{bond_type}"
                # Some bond types might not have been defined if no bonds of that
                # type existed; ignore unfix errors via try/except.
                try:
                    lmp.command(f"unfix {fix_name}")
                except RuntimeError:
                    pass

            # Count bonds after breaking
            lmp.command("variable bonds_now equal bonds")
            bonds_after = int(lmp.extract_variable("bonds_now", None, 0))

            broken_this_iter = bonds_before - bonds_after
            num_broken_total += broken_this_iter
            print(f"Avalanche iteration broke {broken_this_iter} bonds", flush=True)

            if broken_this_iter == 0:
                break  # exit avalanche loop

        # Dump configuration snapshot
        dumpfile = f"dump.step{step_id}.lammpstrj"
        lmp.command(f"dump D all custom 10 {dumpfile} id type x y z")
        lmp.command("run 0 post no")  # produce output without advancing time
        lmp.command("undump D")
        print(
            f"Finished strain step {step_id + 1}; cumulative broken = {num_broken_total}",
            flush=True,
        )

    print("Simulation finished.")


# -----------------------------------------------------------------------------
# CLI
# -----------------------------------------------------------------------------


def build_arg_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="Quasi-static tensile test using LAMMPS")
    p.add_argument("--data-file", required=True, type=pathlib.Path, help="LAMMPS data file path")
    p.add_argument(
        "--thresholds",
        dest="thresholds_file",
        required=True,
        type=pathlib.Path,
        help="Bond breaking thresholds file",
    )
    p.add_argument("--total-steps", type=int, default=200, help="Number of strain steps")
    p.add_argument("--strain-inc", type=float, default=1.0e-3, help="Strain increment per step")
    p.add_argument(
        "--lmp-args",
        nargs=argparse.REMAINDER,
        default=(),
        help="Additional command-line args forwarded to LAMMPS (e.g. -log none)",
    )
    return p


def main(argv: List[str] | None = None):  # pragma: no cover
    parser = build_arg_parser()
    ns = parser.parse_args(argv)

    run_simulation(
        data_file=ns.data_file,
        thresholds_file=ns.thresholds_file,
        total_steps=ns.total_steps,
        strain_inc=ns.strain_inc,
        lmp_cmdargs=tuple(ns.lmp_args),
    )


if __name__ == "__main__":  # pragma: no cover
    main()
