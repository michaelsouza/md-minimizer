"""springs.py
Runs a quasi-static tensile test with avalanche dynamics by driving the top
atoms upward in small strain increments and allowing bond breaking according
to per-bond thresholds read from an external file.

Usage (example):
    python lammps/springs.py \
        --data-file lammps/N12_Lmat4.data \
        --thresholds lammps/N12_Lmat4_breaking_thresholds.dat

Requirements:
    * lammps (Python module, compiled with PYTHON, MC, MOLECULE packages)
    * numpy (only for float casting convenience)

Author: Auto-generated by Cascade AI (2025-06-17)
"""

from __future__ import annotations

import argparse
import pathlib
import sys
from typing import Tuple, List  # pylint: disable=unused-import

try:
    from lammps import lammps  # type: ignore
except ImportError as e:  # pragma: no cover
    sys.stderr.write(
        "Error: LAMMPS python module not found. Ensure you built LAMMPS with the\n"
        "PYTHON package and that it is in PYTHONPATH.\n"
    )
    raise

# -----------------------------------------------------------------------------
# Helper functions
# -----------------------------------------------------------------------------


def parse_thresholds(path: pathlib.Path) -> List[Tuple[int, float]]:
    """Read `thresholds_file` and return list of (bond_type, break_length)."""
    pairs: List[Tuple[int, float]] = []
    with path.open() as fh:
        for line in fh:
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            try:
                bond_type: int = int(parts[0])
                break_len: float = float(parts[1])
            except ValueError:
                continue  # skip malformed lines
            pairs.append((bond_type, break_len))
    if not pairs:
        raise ValueError(f"No valid thresholds found in {path}")
    return pairs


# -----------------------------------------------------------------------------
# Core simulation routine
# -----------------------------------------------------------------------------


def run_simulation(
    data_file: pathlib.Path,
    thresholds_file: pathlib.Path,
    total_steps: int = 200,
    strain_inc: float = 1.0e-3,
    lmp_cmdargs: Tuple[str, ...]=(),
):
    """Executa o teste de tração quase-estático."""
    if not data_file.is_file():
        raise FileNotFoundError(data_file)
    if not thresholds_file.is_file():
        raise FileNotFoundError(thresholds_file)

    # Pré-processa os limites de quebra para acelerar os loops
    threshold_pairs = parse_thresholds(thresholds_file)

    # Cria a instância do LAMMPS
    lmp = lammps(cmdargs=list(lmp_cmdargs))

    # --- Inicialização e definição do sistema ---
    lmp.commands_list(
        [
            "units lj",
            "dimension 2",
            "boundary p s p",
            "atom_style bond",
            "bond_style harmonic",
            "pair_style none",
            f"read_data {data_file}",
            "group bottom_atoms type 2",
            "group top_atoms    type 3",
            "group mobile_atoms type 1",
            "fix 1 bottom_atoms setforce 0.0 0.0 0.0",
            "compute b all property/local btype batom1 batom2",
            "thermo 1",
            "thermo_style custom step pe press pyy",
        ]
    )

    num_broken_total = 0

    for step_id in range(total_steps):
        print(f"--- Strain Step {step_id + 1}/{total_steps} ---", flush=True)

        # Aplica o deslocamento (incremento de deformação)
        lmp.command(f"displace_atoms top_atoms move 0 {strain_inc} 0")

        # Fixa os átomos do topo durante a relaxação/avalanche
        lmp.command("fix 2 top_atoms setforce 0.0 0.0 0.0")

        # Loop da avalanche
        while True:
            lmp.command("minimize 1.0e-5 1.0e-7 1000 10000")

            lmp.command("variable bonds_now equal bonds")
            bonds_before = int(lmp.extract_variable("bonds_now", None, 0))

            for bond_type, break_len in threshold_pairs:
                fix_name = f"Br_{bond_type}"
                lmp.command(f"fix {fix_name} all bond/break 1 {bond_type} {break_len}")

            lmp.command("run 1 post no")

            for bond_type, _ in threshold_pairs:
                fix_name = f"Br_{bond_type}"
                try:
                    lmp.command(f"unfix {fix_name}")
                except RuntimeError:
                    pass

            lmp.command("variable bonds_now equal bonds")
            bonds_after = int(lmp.extract_variable("bonds_now", None, 0))

            broken_this_iter = bonds_before - bonds_after
            num_broken_total += broken_this_iter
            print(f"Avalanche iteration broke {broken_this_iter} bonds", flush=True)

            if broken_this_iter == 0:
                break  # Sai do loop da avalanche

        # Libera os átomos do topo para o próximo passo de deslocamento
        lmp.command("unfix 2")

        # --- Bloco de Dump ---
        # Salva as posições dos átomos em um arquivo
        dumpfile_atoms = f"dump.atoms.step.{step_id}.lammpstrj"
        lmp.command(f"dump D_atom all custom 1 {dumpfile_atoms} id type x y z")

        # Salva as informações das ligações (quais átomos estão conectados) em outro arquivo
        dumpfile_bonds = f"dump.bonds.step.{step_id}.txt"
        lmp.command(f"dump D_bond all local 1 {dumpfile_bonds} c_b[2] c_b[3]")

        # Executa o dump para gerar os arquivos para o passo atual
        lmp.command("run 0 post no")

        # Limpa os dumps para o próximo ciclo
        lmp.command("undump D_atom")
        lmp.command("undump D_bond")
        # --- Fim do Bloco Modificado ---
        
        print(
            f"Finished strain step {step_id + 1}; cumulative broken = {num_broken_total}",
            flush=True,
        )

    print("Simulação finalizada.")


# -----------------------------------------------------------------------------
# CLI
# -----------------------------------------------------------------------------


def build_arg_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="Quasi-static tensile test using LAMMPS")
    p.add_argument(
        "--data-file", required=True, type=pathlib.Path, help="LAMMPS data file path"
    )
    p.add_argument(
        "--thresholds",
        dest="thresholds_file",
        required=True,
        type=pathlib.Path,
        help="Bond breaking thresholds file",
    )
    p.add_argument("--total-steps", type=int, default=10, help="Number of strain steps")
    p.add_argument(
        "--strain-inc", type=float, default=0.1, help="Strain increment per step"
    )
    p.add_argument(
        "--lmp-args",
        nargs=argparse.REMAINDER,
        default=(),
        help="Additional command-line args forwarded to LAMMPS (e.g. -log none)",
    )
    return p


def main(argv: List[str] | None = None):  # pragma: no cover
    parser = build_arg_parser()
    ns = parser.parse_args(argv)

    run_simulation(
        data_file=ns.data_file,
        thresholds_file=ns.thresholds_file,
        total_steps=ns.total_steps,
        strain_inc=ns.strain_inc,
        lmp_cmdargs=tuple(ns.lmp_args),
    )


if __name__ == "__main__":  # pragma: no cover
    main()
